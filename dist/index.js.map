{
  "version": 3,
  "sources": ["../node_modules/@jyostudio/overload/src/constant.js", "../node_modules/@jyostudio/overload/src/index.js", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/codegen/code.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/codegen/scope.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/codegen/index.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/util.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/names.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/errors.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/validate/boolSchema.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/rules.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/validate/applicability.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/validate/dataType.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/validate/defaults.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/code.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/validate/keyword.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/validate/subschema.ts", "../node_modules/@jyostudio/overload/node_modules/fast-deep-equal/index.js", "../node_modules/@jyostudio/overload/node_modules/json-schema-traverse/index.js", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/resolve.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/validate/index.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/runtime/validation_error.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/ref_error.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/compile/index.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/dist/refs/data.json", "../node_modules/@jyostudio/overload/node_modules/fast-uri/lib/scopedChars.js", "../node_modules/@jyostudio/overload/node_modules/fast-uri/lib/utils.js", "../node_modules/@jyostudio/overload/node_modules/fast-uri/lib/schemes.js", "../node_modules/@jyostudio/overload/node_modules/fast-uri/index.js", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/runtime/uri.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/core.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/core/id.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/core/ref.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/core/index.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/limitNumber.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/multipleOf.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/runtime/ucs2length.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/limitLength.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/pattern.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/limitProperties.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/required.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/limitItems.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/runtime/equal.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/const.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/enum.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/validation/index.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/items.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/items2020.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/contains.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/properties.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/not.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/anyOf.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/oneOf.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/allOf.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/if.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/thenElse.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/applicator/index.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/format/format.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/format/index.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/metadata.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/draft7.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/discriminator/types.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/vocabularies/discriminator/index.ts", "../node_modules/@jyostudio/overload/node_modules/ajv/dist/refs/json-schema-draft-07.json", "../node_modules/@jyostudio/overload/node_modules/ajv/lib/ajv.ts", "../node_modules/@jyostudio/overload/node_modules/ajv-i18n/localize/zh/index.js", "../node_modules/@jyostudio/overload/src/jsonSchema.js", "../node_modules/@jyostudio/overload/src/constant.js", "../src/index.js"],
  "sourcesContent": ["/**\r\n * \u4EFB\u610F\u7C7B\u578B\u6807\u5FD7\r\n */\r\nexport const ANY_STR = \"*\";\r\n\r\n/**\r\n * \u5269\u4F59\u53C2\u6570\u6807\u5FD7\r\n */\r\nexport const REST_STR = \"...\";\r\n\r\n/**\r\n * \u7C7B\u578B\u8F6C\u6362\u6807\u5FD7\r\n */\r\nexport const TYPE_CONVERT_STR = \"\u21C4\";\r\n\r\n/**\r\n * \u5185\u90E8\u7C7B\u578B\u7236\u7EA7\u6807\u5FD7\r\n */\r\nexport const INNER_TYPE_FATHER = \"##INNER_TYPE##\";\r\n\r\n/**\r\n * \u5185\u90E8\u7C7B\u578B\u5B50\u7EA7\u6807\u5FD7\r\n */\r\nexport const INNER_TYPE_SON = \"@@INNER_TYPE@@\";\r\n\r\n/**\r\n * \u5185\u90E8\u629B\u51FA\u51FD\u6570\u6807\u5FD7\r\n */\r\nexport const INNER_THROW_FN = \"##INNER_THROW_FN##\";\r\n\r\n/**\r\n * \u5185\u90E8\u7C7B\u578B\u51FD\u6570\u6807\u5FD7\r\n */\r\nexport const INNER_TYPE_FN = \"##INNER_TYPE_FN##\";", "import { ANY_STR, REST_STR, TYPE_CONVERT_STR, INNER_TYPE_FATHER, INNER_TYPE_SON, INNER_TYPE_FN, INNER_THROW_FN } from \"./constant.js\";\r\n\r\n/**\r\n * \u5339\u914D\u7C7B\u578B\r\n * @param {any} param - \u4F20\u5165\u7684\u53C2\u6570\r\n * @param {any} type - \u671F\u671B\u7684\u7C7B\u578B\r\n * @returns {Boolean} \u662F\u5426\u5339\u914D\r\n */\r\nfunction matchType(param, type) {\r\n  if (Array.isArray(type)) {\r\n    for (let i = 0; i < type.length; i++) {\r\n      if (matchType(param, type[i])) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  if (type?.[INNER_TYPE_FN]?.(param)) {\r\n    return true;\r\n  }\r\n\r\n  if (typeof type !== \"function\") {\r\n    if (\r\n      type === ANY_STR && param !== null ||\r\n      type === REST_STR ||\r\n      (type === null && param === null) ||\r\n      type === typeof param\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  switch (typeof param) {\r\n    case \"function\":\r\n    case \"object\":\r\n      break;\r\n    case \"string\": param = String; break;\r\n    case \"number\": param = Number; break;\r\n    case \"boolean\": param = Boolean; break;\r\n    case \"symbol\": param = Symbol; break;\r\n    case \"bigint\": param = BigInt; break;\r\n    default: param = Object(param); break;\r\n  }\r\n\r\n  if (param === type || param instanceof type) {\r\n    return true;\r\n  }\r\n\r\n  if (param?.[INNER_TYPE_SON]) {\r\n    return param[INNER_TYPE_SON] === type?.[INNER_TYPE_FATHER];\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * \u83B7\u53D6\u7C7B\u578B\u540D\u79F0\r\n * @param {any} param - \u4F20\u5165\u7684\u53C2\u6570\r\n * @returns {String} \u7C7B\u578B\u540D\u79F0\r\n */\r\nfunction getTypeName(param) {\r\n  if (param === null) {\r\n    return \"null\";\r\n  }\r\n\r\n  if (param === ANY_STR) {\r\n    return \"(\u4EFB\u610F)\";\r\n  }\r\n\r\n  const paramType = typeof param;\r\n\r\n  if (![\"function\", \"object\"].includes(paramType)) {\r\n    return paramType[0].toUpperCase() + paramType.slice(1);;\r\n  }\r\n\r\n  let className = (param?.name || param?.constructor?.name || \"(\u672A\u77E5)\").split(\" \").pop();\r\n\r\n  [INNER_TYPE_FATHER, INNER_TYPE_SON].forEach(v => {\r\n    if (param?.[v]) {\r\n      className += `<${getTypeName(param?.[v])}>`;\r\n    }\r\n  });\r\n\r\n  if (paramType === \"function\" && className === \"anonymous\") {\r\n    return \"(\u533F\u540D)\";\r\n  }\r\n\r\n  return className;\r\n}\r\n\r\n/**\r\n * \u629B\u51FA\u5806\u6808\u4FE1\u606F\r\n * @param {Error} err - \u9519\u8BEF\u5BF9\u8C61\r\n * @param {...any} args - \u53C2\u6570\u5217\u8868\r\n * @throws {Error}\r\n */\r\nfunction throwStackInfo(err, types, args) {\r\n  const stackList = err.stack.split(\"\\n\").splice(3);\r\n  let errorMessage = \"\";\r\n  let formattedStack = \"\\n\";\r\n  let errorMethodName = \"\";\r\n\r\n  stackList.forEach((stackLine, index, arr) => {\r\n    const parts = stackLine.trim().split(\" \");\r\n    const fullMethodName = parts.length === 3 ? parts[1] : `(\u533F\u540D)`;\r\n    const methodName = fullMethodName.split(\".\").pop();\r\n\r\n    arr[index] = {\r\n      fullMethodName,\r\n      methodName,\r\n      link: parts.length === 3 ? parts[2] : parts[1],\r\n    };\r\n\r\n    if (!index) {\r\n      errorMethodName = methodName;\r\n    } else {\r\n      formattedStack += `${methodName}\\t${arr[index].link}\\n`;\r\n    }\r\n  });\r\n\r\n  const matchingTypes = types.find(v => v.length === args.length);\r\n\r\n  if (!matchingTypes) {\r\n    errorMessage += `\u65B9\u6CD5 ${errorMethodName} \u4E0D\u5B58\u5728 ${args.length} \u4E2A\u53C2\u6570\u7684\u91CD\u8F7D\u3002`;\r\n    errorMessage += formattedStack;\r\n    throw new Error(errorMessage);\r\n  }\r\n\r\n  let hasError = false;\r\n  matchingTypes.forEach((expectedType, i) => {\r\n    if (!matchType(args[i], expectedType)) {\r\n      const expectedTypeNames = Array.isArray(expectedType)\r\n        ? expectedType.map(getTypeName).join(\"\u3001\")\r\n        : getTypeName(expectedType);\r\n\r\n      errorMessage += `${hasError ? \"\\n\" : \"\"}\u53C2\u6570${i + 1}\uFF1A\u9884\u671F ${expectedTypeNames} \u4F46\u5F97\u5230 ${getTypeName(args[i])}\u3002`;\r\n\r\n      if (Array.isArray(expectedType)) {\r\n        expectedType.forEach((type, index) => {\r\n          if (typeof type?.[INNER_THROW_FN] === \"function\") {\r\n            errorMessage += `${index === 0 ? \"\\n\u9644\u52A0\u4FE1\u606F\uFF1A\\n\" : \"\"}\u5C1D\u8BD5\u65B9\u6848${i + 1} - ${type[INNER_THROW_FN]?.(args[i])}`;\r\n          }\r\n        });\r\n      } else if (typeof expectedType?.[INNER_THROW_FN] === \"function\") {\r\n        errorMessage += `\\n\u9644\u52A0\u4FE1\u606F\uFF1A\\n\u5C1D\u8BD5\u65B9\u6848${i + 1} - ${expectedType[INNER_THROW_FN]?.(args[i])}`;\r\n      }\r\n\r\n      hasError = true;\r\n    }\r\n  });\r\n\r\n  if (hasError) {\r\n    errorMessage = `\u65B9\u6CD5 ${errorMethodName} \u8C03\u7528\u9519\u8BEF\\n${errorMessage}`;\r\n    errorMessage += formattedStack;\r\n    throw new Error(errorMessage);\r\n  }\r\n}\r\n\r\n/**\r\n * \u8FD4\u56DE\u4E00\u4E2A\u91CD\u8F7D\u51FD\u6570\r\n * @returns {Function} \u91CD\u8F7D\u51FD\u6570\r\n */\r\nfunction createOverload() {\r\n  const TYPES = [];\r\n  const FNS = [];\r\n  const OPTIONS = [];\r\n  let anyFn = null;\r\n\r\n  /**\r\n   * \u8C03\u7528\u515C\u5E95\u51FD\u6570\r\n   * @param  {...any} args - \u53C2\u6570\u5217\u8868\r\n   * @returns {any} \u8FD4\u56DE\u503C\r\n   */\r\n  function runAny(...args) {\r\n    if (anyFn) {\r\n      return anyFn.apply(this, args);\r\n    }\r\n\r\n    throwStackInfo(new Error(), TYPES, args);\r\n  }\r\n\r\n  /**\r\n   * \u91CD\u8F7D\u51FD\u6570\r\n   * @param {...any} params - \u53C2\u6570\u5217\u8868\r\n   * @returns {any} \u8FD4\u56DE\u503C\r\n   */\r\n  function overload(...params) {\r\n    if (!TYPES.length) {\r\n      return runAny.apply(this, params);\r\n    }\r\n\r\n    const paramsLength = params.length;\r\n\r\n    loop: for (let i = 0; i < TYPES.length; i++) {\r\n      const types = TYPES[i];\r\n      const options = OPTIONS[i];\r\n      const typesLength = types.length;\r\n\r\n      if ((options.length !== paramsLength && !options.rest) ||\r\n        (paramsLength === 0 && typesLength && types[0] !== REST_STR)) {\r\n        continue;\r\n      }\r\n\r\n      for (let j = 0; j < paramsLength; j++) {\r\n        const type = types[j] || types[typesLength - 1];\r\n        if (!matchType(params[j], type)) {\r\n          try {\r\n            const convert = type?.[TYPE_CONVERT_STR]?.(params[j]);\r\n            if (matchType(convert, type)) {\r\n              params[j] = convert;\r\n              continue;\r\n            }\r\n          } catch { }\r\n          continue loop;\r\n        }\r\n      }\r\n\r\n      return FNS[i].apply(this, params);\r\n    }\r\n\r\n    return runAny.apply(this, params);\r\n  }\r\n\r\n  /**\r\n   * \u6DFB\u52A0\u51FD\u6570\u91CD\u8F7D\r\n   * @param {Array} types - \u53C2\u6570\u7C7B\u578B\u5217\u8868\r\n   * @param {Function} fn - \u8981\u8C03\u7528\u7684\u51FD\u6570\r\n   * @returns {Function} \u91CD\u8F7D\u51FD\u6570\r\n   * @throws {TypeError}\r\n   * @throws {Error}\r\n   */\r\n  overload.add = function (types, fn) {\r\n    if (!Array.isArray(TYPES)) {\r\n      throw new TypeError(\"types \u5FC5\u987B\u662F\u6570\u7EC4\u3002\");\r\n    }\r\n\r\n    if (typeof fn !== \"function\") {\r\n      throw new TypeError(\"fn \u5FC5\u987B\u662F\u51FD\u6570\u3002\");\r\n    }\r\n\r\n    for (let i = 0; i < types.length; i++) {\r\n      if (types[i] === REST_STR && i !== types.length - 1) {\r\n        throw new SyntaxError(`${REST_STR} \u5FC5\u987B\u662F\u6700\u540E\u4E00\u4E2A\u53C2\u6570\u3002`);\r\n      }\r\n    }\r\n\r\n    TYPES.forEach((key) => {\r\n      if (key.length !== types.length) {\r\n        return;\r\n      }\r\n\r\n      for (let i = 0; i < key.length; i++) {\r\n        if (key[i] !== types[i]) return;\r\n      }\r\n\r\n      throw new Error(\"\u5DF2\u5B58\u5728\u6B64\u7B7E\u540D\u7684\u91CD\u8F7D\u3002\");\r\n    });\r\n\r\n    TYPES.forEach(type => {\r\n      const isArray = Array.isArray(type);\r\n      if (typeof type !== \"function\" && !isArray && type !== ANY_STR && type !== REST_STR) {\r\n        throw new TypeError(`\u671F\u671B\u7C7B\u578B\u4E3A Class\u3001Array\u3001${ANY_STR} \u6216\u672B\u5C3E\u53C2\u6570\u4E5F\u53EF\u4EE5\u662F ${REST_STR}\u3002`);\r\n      }\r\n\r\n      if (isArray) {\r\n        for (let i = 0; i < type.length; i++) {\r\n          const typeofStr = typeof type[i];\r\n          if (\r\n            typeofStr !== \"function\" &&\r\n            !(typeofStr === \"object\" && typeof type[i]?.constructor === \"function\") &&\r\n            type[i] !== null &&\r\n            type[i] !== ANY_STR\r\n          ) {\r\n            throw new TypeError(`\u7C7B\u578B\u5FC5\u987B\u4E3A Class\u3001null \u6216 ${ANY_STR}\u3002`);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    TYPES.push(types);\r\n    FNS.push(fn);\r\n    OPTIONS.push({\r\n      length: types.length,\r\n      rest: types[types.length - 1] === REST_STR,\r\n    });\r\n\r\n    return overload;\r\n  };\r\n\r\n  /**\r\n   * \u8BBE\u7F6E\u515C\u5E95\u51FD\u6570\r\n   * @param {Function} fn - \u515C\u5E95\u51FD\u6570\r\n   * @returns {Function} \u91CD\u8F7D\u51FD\u6570\r\n   * @throws {TypeError}\r\n   * @throws {Error}\r\n   */\r\n  overload.any = function (fn) {\r\n    if (anyFn) {\r\n      throw new Error(\"any \u51FD\u6570\u5DF2\u5B58\u5728\u3002\");\r\n    }\r\n\r\n    if (typeof fn !== \"function\") {\r\n      throw new TypeError(\"fn \u5FC5\u987B\u662F\u51FD\u6570\u3002\");\r\n    }\r\n\r\n    anyFn = fn;\r\n\r\n    return overload;\r\n  };\r\n\r\n  return overload;\r\n}\r\n\r\nexport default createOverload()\r\n  .add([], function () {\r\n    return createOverload();\r\n  })\r\n  .add([Array, Function], function (types, fn) {\r\n    const result = createOverload();\r\n    result.add(types, fn);\r\n    return result;\r\n  });", "// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n", "import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n", "import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private rhs?: SafeExpr\n  ) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(\n    readonly lhs: Code,\n    public rhs: SafeExpr,\n    private readonly sideEffects?: boolean\n  ) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(\n    lhs: Code,\n    private readonly op: Code,\n    rhs: SafeExpr,\n    sideEffects?: boolean\n  ) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(\n    private condition: Code | boolean,\n    nodes?: ChildNode[]\n  ) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(\n    public name: Name,\n    public args: Code,\n    public async?: boolean\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n", "import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n", "import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n", "import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n", "import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n", "import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = (typeof _jsonTypes)[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n", "import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n", "import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n", "import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n", "import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n", "import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n", "import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n", "import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponent} from \"fast-uri\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponent): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let innerBaseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") innerBaseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = innerBaseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n", "import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n", "import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n", "import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n", "import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport {URIComponent} from \"fast-uri\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URIComponent,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n", "{\n  \"$id\": \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n  \"description\": \"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\n  \"type\": \"object\",\n  \"required\": [\"$data\"],\n  \"properties\": {\n    \"$data\": {\n      \"type\": \"string\",\n      \"anyOf\": [{\"format\": \"relative-json-pointer\"}, {\"format\": \"json-pointer\"}]\n    }\n  },\n  \"additionalProperties\": false\n}\n", "'use strict'\n\nconst HEX = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  a: 10,\n  A: 10,\n  b: 11,\n  B: 11,\n  c: 12,\n  C: 12,\n  d: 13,\n  D: 13,\n  e: 14,\n  E: 14,\n  f: 15,\n  F: 15\n}\n\nmodule.exports = {\n  HEX\n}\n", "'use strict'\n\nconst { HEX } = require('./scopedChars')\n\nfunction normalizeIPv4 (host) {\n  if (findToken(host, '.') < 3) { return { host, isIPV4: false } }\n  const matches = host.match(/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/u) || []\n  const [address] = matches\n  if (address) {\n    return { host: stripLeadingZeros(address, '.'), isIPV4: true }\n  } else {\n    return { host, isIPV4: false }\n  }\n}\n\n/**\n * @param {string[]} input\n * @param {boolean} [keepZero=false]\n * @returns {string|undefined}\n */\nfunction stringArrayToHexStripped (input, keepZero = false) {\n  let acc = ''\n  let strip = true\n  for (const c of input) {\n    if (HEX[c] === undefined) return undefined\n    if (c !== '0' && strip === true) strip = false\n    if (!strip) acc += c\n  }\n  if (keepZero && acc.length === 0) acc = '0'\n  return acc\n}\n\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  const address = []\n  const buffer = []\n  let isZone = false\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  function consume () {\n    if (buffer.length) {\n      if (isZone === false) {\n        const hex = stringArrayToHexStripped(buffer)\n        if (hex !== undefined) {\n          address.push(hex)\n        } else {\n          output.error = true\n          return false\n        }\n      }\n      buffer.length = 0\n    }\n    return true\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume()) { break }\n      tokenCount++\n      address.push(':')\n      if (tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i - 1 >= 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      continue\n    } else if (cursor === '%') {\n      if (!consume()) { break }\n      // switch to zone detection\n      isZone = true\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (isZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\nfunction normalizeIPv6 (host, opts = {}) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, escapedHost, isIPV6: true }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\nfunction stripLeadingZeros (str, token) {\n  let out = ''\n  let skip = true\n  const l = str.length\n  for (let i = 0; i < l; i++) {\n    const c = str[i]\n    if (c === '0' && skip) {\n      if ((i + 1 <= l && str[i + 1] === token) || i + 1 === l) {\n        out += c\n        skip = false\n      }\n    } else {\n      if (c === token) {\n        skip = true\n      } else {\n        skip = false\n      }\n      out += c\n    }\n  }\n  return out\n}\n\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\nconst RDS1 = /^\\.\\.?\\//u\nconst RDS2 = /^\\/\\.(?:\\/|$)/u\nconst RDS3 = /^\\/\\.\\.(?:\\/|$)/u\nconst RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/u\n\nfunction removeDotSegments (input) {\n  const output = []\n\n  while (input.length) {\n    if (input.match(RDS1)) {\n      input = input.replace(RDS1, '')\n    } else if (input.match(RDS2)) {\n      input = input.replace(RDS2, '/')\n    } else if (input.match(RDS3)) {\n      input = input.replace(RDS3, '/')\n      output.pop()\n    } else if (input === '.' || input === '..') {\n      input = ''\n    } else {\n      const im = input.match(RDS5)\n      if (im) {\n        const s = im[0]\n        input = input.slice(s.length)\n        output.push(s)\n      } else {\n        throw new Error('Unexpected dot segment condition')\n      }\n    }\n  }\n  return output.join('')\n}\n\nfunction normalizeComponentEncoding (components, esc) {\n  const func = esc !== true ? escape : unescape\n  if (components.scheme !== undefined) {\n    components.scheme = func(components.scheme)\n  }\n  if (components.userinfo !== undefined) {\n    components.userinfo = func(components.userinfo)\n  }\n  if (components.host !== undefined) {\n    components.host = func(components.host)\n  }\n  if (components.path !== undefined) {\n    components.path = func(components.path)\n  }\n  if (components.query !== undefined) {\n    components.query = func(components.query)\n  }\n  if (components.fragment !== undefined) {\n    components.fragment = func(components.fragment)\n  }\n  return components\n}\n\nfunction recomposeAuthority (components, options) {\n  const uriTokens = []\n\n  if (components.userinfo !== undefined) {\n    uriTokens.push(components.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (components.host !== undefined) {\n    let host = unescape(components.host)\n    const ipV4res = normalizeIPv4(host)\n\n    if (ipV4res.isIPV4) {\n      host = ipV4res.host\n    } else {\n      const ipV6res = normalizeIPv6(ipV4res.host, { isIPV4: false })\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = components.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof components.port === 'number' || typeof components.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(components.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  normalizeIPv4,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n", "'use strict'\n\nconst UUID_REG = /^[\\da-f]{8}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{4}\\b-[\\da-f]{12}$/iu\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nfunction isSecure (wsComponents) {\n  return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'\n}\n\nfunction httpParse (components) {\n  if (!components.host) {\n    components.error = components.error || 'HTTP URIs must have a host.'\n  }\n\n  return components\n}\n\nfunction httpSerialize (components) {\n  const secure = String(components.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (components.port === (secure ? 443 : 80) || components.port === '') {\n    components.port = undefined\n  }\n\n  // normalize the empty path\n  if (!components.path) {\n    components.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return components\n}\n\nfunction wsParse (wsComponents) {\n// indicate if the secure flag is set\n  wsComponents.secure = isSecure(wsComponents)\n\n  // construct resouce name\n  wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')\n  wsComponents.path = undefined\n  wsComponents.query = undefined\n\n  return wsComponents\n}\n\nfunction wsSerialize (wsComponents) {\n// normalize the default port\n  if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {\n    wsComponents.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponents.secure === 'boolean') {\n    wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')\n    wsComponents.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponents.resourceName) {\n    const [path, query] = wsComponents.resourceName.split('?')\n    wsComponents.path = (path && path !== '/' ? path : undefined)\n    wsComponents.query = query\n    wsComponents.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponents.fragment = undefined\n\n  return wsComponents\n}\n\nfunction urnParse (urnComponents, options) {\n  if (!urnComponents.path) {\n    urnComponents.error = 'URN can not be parsed'\n    return urnComponents\n  }\n  const matches = urnComponents.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponents.scheme || 'urn'\n    urnComponents.nid = matches[1].toLowerCase()\n    urnComponents.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`\n    const schemeHandler = SCHEMES[urnScheme]\n    urnComponents.path = undefined\n\n    if (schemeHandler) {\n      urnComponents = schemeHandler.parse(urnComponents, options)\n    }\n  } else {\n    urnComponents.error = urnComponents.error || 'URN can not be parsed.'\n  }\n\n  return urnComponents\n}\n\nfunction urnSerialize (urnComponents, options) {\n  const scheme = options.scheme || urnComponents.scheme || 'urn'\n  const nid = urnComponents.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = SCHEMES[urnScheme]\n\n  if (schemeHandler) {\n    urnComponents = schemeHandler.serialize(urnComponents, options)\n  }\n\n  const uriComponents = urnComponents\n  const nss = urnComponents.nss\n  uriComponents.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponents\n}\n\nfunction urnuuidParse (urnComponents, options) {\n  const uuidComponents = urnComponents\n  uuidComponents.uuid = uuidComponents.nss\n  uuidComponents.nss = undefined\n\n  if (!options.tolerant && (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {\n    uuidComponents.error = uuidComponents.error || 'UUID is not valid.'\n  }\n\n  return uuidComponents\n}\n\nfunction urnuuidSerialize (uuidComponents) {\n  const urnComponents = uuidComponents\n  // normalize UUID\n  urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()\n  return urnComponents\n}\n\nconst http = {\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst https = {\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n}\n\nconst ws = {\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n}\n\nconst wss = {\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n}\n\nconst urn = {\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n}\n\nconst urnuuid = {\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n}\n\nconst SCHEMES = {\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n}\n\nmodule.exports = SCHEMES\n", "'use strict'\n\nconst { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require('./lib/utils')\nconst SCHEMES = require('./lib/schemes')\n\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = serialize(parse(uri, options), options)\n  } else if (typeof uri === 'object') {\n    uri = parse(serialize(uri, options), options)\n  }\n  return uri\n}\n\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = Object.assign({ scheme: 'null' }, options)\n  const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  return serialize(resolved, { ...schemelessOptions, skipEscape: true })\n}\n\nfunction resolveComponents (base, relative, options, skipNormalization) {\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base components\n    relative = parse(serialize(relative, options), options) // normalize relative components\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path.charAt(0) === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\nfunction serialize (cmpts, opts) {\n  const components = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options)\n\n  if (components.path !== undefined) {\n    if (!options.skipEscape) {\n      components.path = escape(components.path)\n\n      if (components.scheme !== undefined) {\n        components.path = components.path.split('%3A').join(':')\n      }\n    } else {\n      components.path = unescape(components.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && components.scheme) {\n    uriTokens.push(components.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(components, options)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (components.path && components.path.charAt(0) !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (components.path !== undefined) {\n    let s = components.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (authority === undefined) {\n      s = s.replace(/^\\/\\//u, '/%2F') // don't allow the path to start with \"//\"\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (components.query !== undefined) {\n    uriTokens.push('?', components.query)\n  }\n\n  if (components.fragment !== undefined) {\n    uriTokens.push('#', components.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst hexLookUp = Array.from({ length: 127 }, (v, k) => /[^!\"$&'()*+,\\-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))\n\nfunction nonSimpleDomain (value) {\n  let code = 0\n  for (let i = 0, len = value.length; i < len; ++i) {\n    code = value.charCodeAt(i)\n    if (code > 126 || hexLookUp[code]) {\n      return true\n    }\n  }\n  return false\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n  const gotEncoding = uri.indexOf('%') !== -1\n  let isIP = false\n  if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = normalizeIPv4(parsed.host)\n      if (ipv4result.isIPV4 === false) {\n        const ipv6result = normalizeIPv6(ipv4result.host, { isIPV4: false })\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        parsed.host = ipv4result.host\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && !parsed.path && parsed.query === undefined) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (gotEncoding && parsed.scheme !== undefined) {\n        parsed.scheme = unescape(parsed.scheme)\n      }\n      if (gotEncoding && parsed.host !== undefined) {\n        parsed.host = unescape(parsed.host)\n      }\n      if (parsed.path !== undefined && parsed.path.length) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment !== undefined && parsed.fragment.length) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponents,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n", "import * as uri from \"fast-uri\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n", "export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n", "import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n", "import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n", "// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n", "// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n", "import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n", "import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n", "import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n", "import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n", "import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n", "import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n", "import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n", "import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n", "import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n", "import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n", "import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          const ref = sch.$ref\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n", "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Core schema meta-schema\",\n  \"definitions\": {\n    \"schemaArray\": {\n      \"type\": \"array\",\n      \"minItems\": 1,\n      \"items\": {\"$ref\": \"#\"}\n    },\n    \"nonNegativeInteger\": {\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"nonNegativeIntegerDefault0\": {\n      \"allOf\": [{\"$ref\": \"#/definitions/nonNegativeInteger\"}, {\"default\": 0}]\n    },\n    \"simpleTypes\": {\n      \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n    },\n    \"stringArray\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"uniqueItems\": true,\n      \"default\": []\n    }\n  },\n  \"type\": [\"object\", \"boolean\"],\n  \"properties\": {\n    \"$id\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$schema\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"$ref\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$comment\": {\n      \"type\": \"string\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"default\": true,\n    \"readOnly\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"examples\": {\n      \"type\": \"array\",\n      \"items\": true\n    },\n    \"multipleOf\": {\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"maximum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMaximum\": {\n      \"type\": \"number\"\n    },\n    \"minimum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMinimum\": {\n      \"type\": \"number\"\n    },\n    \"maxLength\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minLength\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"pattern\": {\n      \"type\": \"string\",\n      \"format\": \"regex\"\n    },\n    \"additionalItems\": {\"$ref\": \"#\"},\n    \"items\": {\n      \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/schemaArray\"}],\n      \"default\": true\n    },\n    \"maxItems\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minItems\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"uniqueItems\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"contains\": {\"$ref\": \"#\"},\n    \"maxProperties\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minProperties\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"required\": {\"$ref\": \"#/definitions/stringArray\"},\n    \"additionalProperties\": {\"$ref\": \"#\"},\n    \"definitions\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"properties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"patternProperties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"propertyNames\": {\"format\": \"regex\"},\n      \"default\": {}\n    },\n    \"dependencies\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/stringArray\"}]\n      }\n    },\n    \"propertyNames\": {\"$ref\": \"#\"},\n    \"const\": true,\n    \"enum\": {\n      \"type\": \"array\",\n      \"items\": true,\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"type\": {\n      \"anyOf\": [\n        {\"$ref\": \"#/definitions/simpleTypes\"},\n        {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/definitions/simpleTypes\"},\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      ]\n    },\n    \"format\": {\"type\": \"string\"},\n    \"contentMediaType\": {\"type\": \"string\"},\n    \"contentEncoding\": {\"type\": \"string\"},\n    \"if\": {\"$ref\": \"#\"},\n    \"then\": {\"$ref\": \"#\"},\n    \"else\": {\"$ref\": \"#\"},\n    \"allOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"anyOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"oneOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"not\": {\"$ref\": \"#\"}\n  },\n  \"default\": true\n}\n", "import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nexport class Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nmodule.exports.Ajv = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n", "\"use strict\"\nmodule.exports = function localize_zh(errors) {\n  if (!(errors && errors.length)) return\n  for (const e of errors) {\n    let out\n    switch (e.keyword) {\n      case \"additionalItems\":\n      case \"items\":\n        out = \"\"\n        var n = e.params.limit\n        out += \"\u4E0D\u5141\u8BB8\u8D85\u8FC7\" + n + \"\u4E2A\u5143\u7D20\"\n        break\n      case \"additionalProperties\":\n        out = \"\u4E0D\u5141\u8BB8\u6709\u989D\u5916\u7684\u5C5E\u6027\"\n        break\n      case \"anyOf\":\n        out = \"\u6570\u636E\u5E94\u4E3A anyOf \u6240\u6307\u5B9A\u7684\u5176\u4E2D\u4E00\u4E2A\"\n        break\n      case \"const\":\n        out = \"\u5E94\u5F53\u7B49\u4E8E\u5E38\u91CF\"\n        break\n      case \"contains\":\n        out = \"\u5E94\u5F53\u5305\u542B\u4E00\u4E2A\u6709\u6548\u9879\"\n        break\n      case \"dependencies\":\n      case \"dependentRequired\":\n        out = \"\"\n        var n = e.params.depsCount\n        out += \"\u5E94\u5F53\u62E5\u6709\u5C5E\u6027\" + e.params.property + \"\u7684\u4F9D\u8D56\u5C5E\u6027\" + e.params.deps\n        break\n      case \"discriminator\":\n        switch (e.params.error) {\n          case \"tag\":\n            out = '\u6807\u7B7E \"' + e.params.tag + '\" \u7684\u7C7B\u578B\u5FC5\u987B\u4E3A\u5B57\u7B26\u4E32'\n            break\n          case \"mapping\":\n            out = '\u6807\u7B7E \"' + e.params.tag + '\" \u7684\u503C\u5FC5\u987B\u5728 oneOf \u4E4B\u4E2D'\n            break\n          default:\n            out = '\u5E94\u5F53\u901A\u8FC7 \"' + e.keyword + ' \u5173\u952E\u8BCD\u6821\u9A8C\"'\n        }\n        break\n      case \"enum\":\n        out = \"\u5E94\u5F53\u662F\u9884\u8BBE\u5B9A\u7684\u679A\u4E3E\u503C\u4E4B\u4E00\"\n        break\n      case \"false schema\":\n        out = \"\u5E03\u5C14\u6A21\u5F0F\u51FA\u9519\"\n        break\n      case \"format\":\n        out = '\u5E94\u5F53\u5339\u914D\u683C\u5F0F \"' + e.params.format + '\"'\n        break\n      case \"formatMaximum\":\n      case \"formatExclusiveMaximum\":\n        out = \"\"\n        var cond = e.params.comparison + \" \" + e.params.limit\n        out += \"\u5E94\u5F53\u662F \" + cond\n        break\n      case \"formatMinimum\":\n      case \"formatExclusiveMinimum\":\n        out = \"\"\n        var cond = e.params.comparison + \" \" + e.params.limit\n        out += \"\u5E94\u5F53\u662F \" + cond\n        break\n      case \"if\":\n        out = '\u5E94\u5F53\u5339\u914D\u6A21\u5F0F \"' + e.params.failingKeyword + '\" '\n        break\n      case \"maximum\":\n      case \"exclusiveMaximum\":\n        out = \"\"\n        var cond = e.params.comparison + \" \" + e.params.limit\n        out += \"\u5E94\u5F53\u4E3A \" + cond\n        break\n      case \"maxItems\":\n        out = \"\"\n        var n = e.params.limit\n        out += \"\u4E0D\u5E94\u591A\u4E8E \" + n + \" \u4E2A\u9879\"\n        break\n      case \"maxLength\":\n        out = \"\"\n        var n = e.params.limit\n        out += \"\u4E0D\u5E94\u591A\u4E8E \" + n + \" \u4E2A\u5B57\u7B26\"\n        break\n      case \"maxProperties\":\n        out = \"\"\n        var n = e.params.limit\n        out += \"\u4E0D\u5E94\u6709\u591A\u4E8E \" + n + \" \u4E2A\u5C5E\u6027\"\n        break\n      case \"minimum\":\n      case \"exclusiveMinimum\":\n        out = \"\"\n        var cond = e.params.comparison + \" \" + e.params.limit\n        out += \"\u5E94\u5F53\u4E3A \" + cond\n        break\n      case \"minItems\":\n        out = \"\"\n        var n = e.params.limit\n        out += \"\u4E0D\u5E94\u5C11\u4E8E \" + n + \" \u4E2A\u9879\"\n        break\n      case \"minLength\":\n        out = \"\"\n        var n = e.params.limit\n        out += \"\u4E0D\u5E94\u5C11\u4E8E \" + n + \" \u4E2A\u5B57\u7B26\"\n        break\n      case \"minProperties\":\n        out = \"\"\n        var n = e.params.limit\n        out += \"\u4E0D\u5E94\u6709\u5C11\u4E8E \" + n + \" \u4E2A\u5C5E\u6027\"\n        break\n      case \"multipleOf\":\n        out = \"\u5E94\u5F53\u662F \" + e.params.multipleOf + \" \u7684\u6574\u6570\u500D\"\n        break\n      case \"not\":\n        out = '\u4E0D\u5E94\u5F53\u5339\u914D \"not\" schema'\n        break\n      case \"oneOf\":\n        out = '\u53EA\u80FD\u5339\u914D\u4E00\u4E2A \"oneOf\" \u4E2D\u7684 schema'\n        break\n      case \"pattern\":\n        out = '\u5E94\u5F53\u5339\u914D\u6A21\u5F0F \"' + e.params.pattern + '\"'\n        break\n      case \"patternRequired\":\n        out = \"\u5E94\u5F53\u6709\u5C5E\u6027\u5339\u914D\u6A21\u5F0F \" + e.params.missingPattern\n        break\n      case \"propertyNames\":\n        out = \"\u5C5E\u6027\u540D \u65E0\u6548\"\n        break\n      case \"required\":\n        out = \"\u5E94\u5F53\u6709\u5FC5\u9700\u5C5E\u6027 \" + e.params.missingProperty\n        break\n      case \"type\":\n        out = \"\u5E94\u5F53\u662F \" + e.params.type + \" \u7C7B\u578B\"\n        break\n      case \"unevaluatedItems\":\n        out = \"\"\n        var n = e.params.len\n        out += \" \u4E0D\u5141\u8BB8\u6709\u8D85\u8FC7 \" + n + \" \u4E2A\u5143\u7D20\"\n        break\n      case \"unevaluatedProperties\":\n        out = \"\u4E0D\u5141\u8BB8\u5B58\u5728\u672A\u6C42\u503C\u7684\u5C5E\u6027\"\n        break\n      case \"uniqueItems\":\n        out =\n          \"\u4E0D\u5E94\u5F53\u542B\u6709\u91CD\u590D\u9879 (\u7B2C \" +\n          e.params.j +\n          \" \u9879\u4E0E\u7B2C \" +\n          e.params.i +\n          \" \u9879\u662F\u91CD\u590D\u7684)\"\n        break\n      default:\n        out = '\u5E94\u5F53\u901A\u8FC7 \"' + e.keyword + ' \u5173\u952E\u8BCD\u6821\u9A8C\"'\n    }\n    e.message = out\n  }\n}\n", "import Ajv from \"ajv\";\r\nimport { INNER_TYPE_FN, INNER_THROW_FN } from \"./constant.js\";\r\nconst localize = require(\"ajv-i18n/localize/zh\");\r\n\r\nconst ajv = new Ajv({ allErrors: true });\r\n\r\nexport default class JSONSchema {\r\n    #validate;\r\n\r\n    constructor(...params) {\r\n        if (params.length !== 1) {\r\n            throw new Error(\"\u53EA\u80FD\u4F20\u5165\u4E00\u4E2A\u5BF9\u8C61\u3002\");\r\n        }\r\n\r\n        if (typeof params[0] !== \"object\") {\r\n            throw new TypeError(\"\u53C2\u6570\u5FC5\u987B\u662F\u5BF9\u8C61\u3002\");\r\n        }\r\n\r\n        this.#validate = ajv.compile(params[0]);\r\n    }\r\n\r\n    [INNER_TYPE_FN](obj) {\r\n        return !!this.#validate(obj);\r\n    }\r\n\r\n    [INNER_THROW_FN](obj) {\r\n        if (!this.#validate(obj)) {\r\n            localize(this.#validate.errors);\r\n            return \"JSON Schema \u6821\u9A8C\u9519\u8BEF\uFF1A\\n\" + JSON.stringify(this.#validate.errors, null, 2);\r\n        }\r\n        return \"\";\r\n    }\r\n}", "/**\r\n * \u4EFB\u610F\u7C7B\u578B\u6807\u5FD7\r\n */\r\nexport const ANY_STR = \"*\";\r\n\r\n/**\r\n * \u5269\u4F59\u53C2\u6570\u6807\u5FD7\r\n */\r\nexport const REST_STR = \"...\";\r\n\r\n/**\r\n * \u7C7B\u578B\u8F6C\u6362\u6807\u5FD7\r\n */\r\nexport const TYPE_CONVERT_STR = \"\u21C4\";\r\n\r\n/**\r\n * \u5185\u90E8\u7C7B\u578B\u7236\u7EA7\u6807\u5FD7\r\n */\r\nexport const INNER_TYPE_FATHER = \"##INNER_TYPE##\";\r\n\r\n/**\r\n * \u5185\u90E8\u7C7B\u578B\u5B50\u7EA7\u6807\u5FD7\r\n */\r\nexport const INNER_TYPE_SON = \"@@INNER_TYPE@@\";\r\n\r\n/**\r\n * \u5185\u90E8\u629B\u51FA\u51FD\u6570\u6807\u5FD7\r\n */\r\nexport const INNER_THROW_FN = \"##INNER_THROW_FN##\";\r\n\r\n/**\r\n * \u5185\u90E8\u7C7B\u578B\u51FD\u6570\u6807\u5FD7\r\n */\r\nexport const INNER_TYPE_FN = \"##INNER_TYPE_FN##\";", "import overload from \"@jyostudio/overload\";\r\nimport JSONSchema from \"@jyostudio/overload/dist/jsonSchema.js\";\r\n\r\n/**\r\n * @template T\r\n * @class List\r\n */\r\nexport default class List {\r\n    /**\r\n     * \u5143\u7D20\u5217\u8868\r\n     * @type {T[]}\r\n     */\r\n    #list = [];\r\n\r\n    /**\r\n     * \u5185\u90E8\u7C7B\u578B\r\n     * @type {T}\r\n     */\r\n    #innerType = null;\r\n\r\n    /**\r\n     * \u4EE3\u7406\r\n     * @type {Proxy<List>}\r\n     */\r\n    #proxy = null;\r\n\r\n    get length() {\r\n        return this.#list.length;\r\n    }\r\n\r\n    get [Symbol.isConcatSpreadable]() {\r\n        return true;\r\n    }\r\n\r\n    get [Symbol.toStringTag]() {\r\n        return `List<${this.#innerType.name}>`;\r\n    }\r\n\r\n    static #_constructor = function (...params) {\r\n        List.#_constructor = overload()\r\n            .add([[Function, JSONSchema]],\r\n                /**\r\n                 * @this {List<T>}\r\n                 * @param {T} innerType - \u5185\u90E8\u7C7B\u578B\r\n                 */\r\n                function (innerType) {\r\n                    this.#innerType = innerType;\r\n                })\r\n            .add([[Function, JSONSchema], [Array, List.T(typeof params?.[0] === \"function\" ? params[0] : class { })]],\r\n                /**\r\n                 * @this {List<T>}\r\n                 * @param {T} innerType - \u5185\u90E8\u7C7B\u578B\r\n                 * @param {T[] | List<T>} list - \u5217\u8868\r\n                 */\r\n                function (innerType, list) {\r\n                    this.#innerType = innerType;\r\n                    for (let item of list) {\r\n                        this.add(item);\r\n                    }\r\n                })\r\n            .add([[Function, JSONSchema], Number], function (innerType, count) {\r\n                this.#innerType = innerType;\r\n                let defaultValue;\r\n\r\n                if (innerType === Number) defaultValue = 0;\r\n                else if (innerType === String) defaultValue = \"\";\r\n                else if (innerType === Boolean) defaultValue = false;\r\n                else if (innerType === BigInt) defaultValue = BigInt(0);\r\n                else if (innerType === Symbol) defaultValue = Symbol();\r\n                else defaultValue = null;\r\n\r\n                for (let i = 0; i < count; i++) {\r\n                    this.add(innerType?.[\"##STRUCT_CONSTURCTOR##\"]?.() || defaultValue);\r\n                }\r\n            });\r\n\r\n        return List.#_constructor.call(this, ...params);\r\n    };\r\n\r\n    constructor(...params) {\r\n        List.#_constructor.apply(this, params);\r\n\r\n        return this.#initProxy();\r\n    }\r\n\r\n    static T(...params) {\r\n        const CACHE_T_PROXY = new WeakMap();\r\n\r\n        List.T = overload([[Function, JSONSchema]], function (innerType) {\r\n            let proxy = CACHE_T_PROXY.get(innerType);\r\n            !proxy && CACHE_T_PROXY.set(innerType, proxy = new Proxy(List, {\r\n                get: (target, prop, receiver) => {\r\n                    if (prop === \"##INNER_TYPE##\") {\r\n                        return innerType;\r\n                    }\r\n                    return target[prop];\r\n                }\r\n            }));\r\n\r\n            return proxy;\r\n        });\r\n\r\n        return List.T(...params);\r\n    }\r\n\r\n    #initProxy() {\r\n        return this.#proxy = new Proxy(this, {\r\n            get: (target, prop, receiver) => {\r\n                if (prop === \"@@INNER_TYPE@@\") {\r\n                    return this.#innerType;\r\n                }\r\n\r\n                let result = null;\r\n\r\n                if (typeof prop === \"symbol\") {\r\n                    result = this[prop];\r\n                } else if (typeof prop === \"string\") {\r\n                    if (/^\\d+$/.test(prop)) {\r\n                        result = this.#list[prop];\r\n                    } else {\r\n                        result = this[prop];\r\n                    }\r\n                }\r\n\r\n                if (typeof result === \"function\") {\r\n                    return result.bind(this);\r\n                }\r\n\r\n                return result;\r\n            },\r\n            set: (target, prop, value, receiver) => {\r\n                if (typeof prop === \"string\" && /^\\d+$/.test(prop)) {\r\n                    if (prop >= this.#list.length) {\r\n                        throw new Error(`\u7D22\u5F15 ${prop} \u8D85\u51FA\u8303\u56F4\uFF0C\u5217\u8868\u957F\u5EA6\u4E3A ${this.#list.length}\u3002`);\r\n                    }\r\n\r\n                    overload([this.#innerType],\r\n                        /**\r\n                         * @param {T} value - \u503C\r\n                         */\r\n                        (value) => {\r\n                            this.#list[prop] = value;\r\n                        }).call(this, value);\r\n\r\n                    return true;\r\n                }\r\n\r\n                throw new Error(`\u65E0\u6CD5\u5728\u6B64\u5217\u8868\u4E0A\u8BBE\u7F6E\u5C5E\u6027 ${prop}\u3002`);\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {Number} index - \u7D22\u5F15\r\n     * @throws {Error}\r\n     */\r\n    #rangeCheck(index) {\r\n        if (index < 0) {\r\n            throw new Error(`\u7D22\u5F15 ${index} \u8D85\u51FA\u8303\u56F4\uFF0C\u7D22\u5F15\u5FC5\u987B\u5927\u4E8E\u6216\u7B49\u4E8E 0\u3002`);\r\n        }\r\n\r\n        if (index >= this.#list.length) {\r\n            throw new Error(`\u7D22\u5F15 ${index} \u8D85\u51FA\u8303\u56F4\uFF0C\u5217\u8868\u957F\u5EA6\u4E3A ${this.#list.length}\u3002`);\r\n        }\r\n    }\r\n\r\n    [Symbol.iterator] = function* () {\r\n        for (let i = 0; i < this.#list.length; i++) {\r\n            yield this.#list[i];\r\n        }\r\n    }\r\n\r\n    add(...params) {\r\n        this.add = overload([[this.#innerType, null]],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {T | null} item \r\n             */\r\n            function (item) {\r\n                this.#list.push(item);\r\n            });\r\n\r\n        return this.add(...params);\r\n    }\r\n\r\n    addRange(...params) {\r\n        List.prototype.addRange = overload([[Array, List]],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {T[] | List<T>} list - \u5217\u8868\r\n             */\r\n            function (list) {\r\n                for (let item of list) {\r\n                    this.add(item);\r\n                }\r\n            }).any(\r\n                /**\r\n                 * @this {List<T>}\r\n                 * @param {T[]} items - \u9879\u76EE\r\n                 */\r\n                function (...items) {\r\n                    for (let item of items) {\r\n                        this.add(item);\r\n                    }\r\n                });\r\n\r\n        return this.addRange(...params);\r\n    }\r\n\r\n    asReadOnly(...params) {\r\n        const ignore = [\"add\", \"addRange\", \"insert\", \"insertRange\", \"remove\", \"removeAt\", \"removeAll\", \"removeRange\", \"clear\", \"reverse\", \"sort\", \"asReadOnly\"];\r\n\r\n        List.prototype.asReadOnly = overload([],\r\n            /**\r\n             * @this {List<T>}\r\n             * @returns {Proxy<List<T>>}\r\n             */\r\n            function () {\r\n                return new Proxy(this, {\r\n                    get: (target, prop, receiver) => {\r\n                        if (ignore.includes(prop)) {\r\n                            throw new Error(`\u65E0\u6CD5\u8BBF\u95EE\u53EA\u8BFB\u5217\u8868\u4E0A\u7684\u65B9\u6CD5 ${prop}\u3002`);\r\n                        }\r\n\r\n                        return this.#proxy[prop];\r\n                    },\r\n                    set: (target, prop, value, receiver) => {\r\n                        throw new Error(`\u65E0\u6CD5\u5728\u53EA\u8BFB\u5217\u8868\u4E0A\u8BBE\u7F6E\u5C5E\u6027 ${prop}\u3002`);\r\n                    }\r\n                });\r\n            });\r\n\r\n        return this.asReadOnly(...params);\r\n    }\r\n\r\n    concat(...params) {\r\n        List.prototype.concat = overload([[Array, List]],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {T[] | List<T>} list - \u5217\u8868\r\n             */\r\n            function (list) {\r\n                /**\r\n                 * @type {List<T>}\r\n                 */\r\n                const newList = new List(this.#innerType);\r\n                for (let item of this) {\r\n                    newList.add(item);\r\n                }\r\n                for (let item of list) {\r\n                    newList.add(item);\r\n                }\r\n                return newList;\r\n            });\r\n\r\n        return this.concat(...params);\r\n    }\r\n\r\n    clear(...params) {\r\n        List.prototype.clear = overload([],\r\n            /**\r\n             * @this {List<T>}\r\n             */\r\n            function () {\r\n                this.#list = [];\r\n            });\r\n\r\n        return this.clear(...params);\r\n    }\r\n\r\n    clone(...params) {\r\n        List.prototype.clone = overload([],\r\n            /**\r\n             * @this {List<T>}\r\n             * @returns {List<T>}\r\n             */\r\n            function () {\r\n                return new List(this.#innerType, this);\r\n            });\r\n\r\n        return this.clone(...params);\r\n    }\r\n\r\n    contains(...params) {\r\n        this.contains = overload([this.#innerType],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {T} item\r\n             * @returns {Boolean}\r\n             */\r\n            function (item) {\r\n                return this.#list.includes(item);\r\n            });\r\n\r\n        return this.contains(...params);\r\n    }\r\n\r\n    copyTo(...params) {\r\n        List.prototype.copyTo = overload()\r\n            .add([Array],\r\n                /**\r\n                 * @this {List<T>}\r\n                 * @param {T[]} array - \u6570\u7EC4\r\n                 */\r\n                function (array) {\r\n                    this.#list.forEach((item, index) => {\r\n                        array[index] = item;\r\n                    });\r\n                })\r\n            .add([Array, Number],\r\n                /**\r\n                 * @this {List<T>}\r\n                 * @param {T[]} array - \u6570\u7EC4\r\n                 * @param {Number} arrayIndex - \u6570\u7EC4\u7D22\u5F15\r\n                 */\r\n                function (array, arrayIndex) {\r\n                    this.#list.forEach((item, index) => {\r\n                        array[arrayIndex + index] = item;\r\n                    });\r\n                })\r\n            .add([Array, Number, Number],\r\n                /**\r\n                 * @this {List<T>}\r\n                 * @param {T[]} array - \u6570\u7EC4\r\n                 * @param {Number} arrayIndex - \u6570\u7EC4\u7D22\u5F15\r\n                 * @param {Number} count - \u6570\u91CF\r\n                 */\r\n                function (array, arrayIndex, count) {\r\n                    for (let i = 0; i < count; i++) {\r\n                        array[arrayIndex + i] = this.#list[i];\r\n                    }\r\n                });\r\n\r\n        return this.copyTo(...params);\r\n    }\r\n\r\n    exists(...params) {\r\n        List.prototype.exists = overload([Function],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Function} predicate - \u8C13\u8BCD\r\n             * @returns {Boolean}\r\n             */\r\n            function (predicate) {\r\n                return this.#list.some(predicate);\r\n            });\r\n\r\n        return this.exists(...params);\r\n    }\r\n\r\n    forEach(...params) {\r\n        List.prototype.forEach = overload([Function],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Function} callback - \u56DE\u8C03\r\n             */\r\n            function (callback) {\r\n                this.#list.forEach(callback);\r\n            });\r\n\r\n        return this.forEach(...params);\r\n    }\r\n\r\n    find(...params) {\r\n        List.prototype.find = overload([Function],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Function} predicate - \u8C13\u8BCD\r\n             * @returns {T?}\r\n             */\r\n            function (predicate) {\r\n                return this.#list.find(predicate);\r\n            });\r\n\r\n        return this.find(...params);\r\n    }\r\n\r\n    findIndex(...params) {\r\n        List.prototype.findIndex = overload([Function],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Function} predicate - \u8C13\u8BCD\r\n             * @returns {Number}\r\n             */\r\n            function (predicate) {\r\n                return this.#list.findIndex(predicate);\r\n            });\r\n\r\n        return this.findIndex(...params);\r\n    }\r\n\r\n    findLast(...params) {\r\n        List.prototype.findLast = overload([Function],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Function} predicate - \u8C13\u8BCD\r\n             * @returns {T?} \r\n             */\r\n            function (predicate) {\r\n                this.#list.reverse();\r\n                let find = this.#list.find(predicate);\r\n                this.#list.reverse();\r\n                return find;\r\n            });\r\n\r\n        return this.findLast(...params);\r\n    }\r\n\r\n    findLastIndex(...params) {\r\n        List.prototype.findLastIndex = overload([Function],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Function} predicate - \u8C13\u8BCD\r\n             * @returns {Number}\r\n             */\r\n            function (predicate) {\r\n                this.#list.reverse();\r\n                let find = this.#list.findIndex(predicate);\r\n                this.#list.reverse();\r\n                return find;\r\n            });\r\n\r\n        return this.findLastIndex(...params);\r\n    }\r\n\r\n    getInnerType(...params) {\r\n        List.prototype.getInnerType = overload([],\r\n            /**\r\n             * @this {List<T>}\r\n             * @returns {T}\r\n             */\r\n            function () {\r\n                return this.#innerType;\r\n            });\r\n\r\n        return this.getInnerType(...params);\r\n    }\r\n\r\n    insert(...params) {\r\n        this.insert = overload([Number, [this.#innerType, null]],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Number} index - \u7D22\u5F15\r\n             * @param {T | null} item - \u9879\u76EE\r\n             */\r\n            function (index, item) {\r\n                this.#rangeCheck(index);\r\n\r\n                this.#list.splice(index, 0, item);\r\n            });\r\n\r\n        return this.insert(...params);\r\n    }\r\n\r\n    insertRange(...params) {\r\n        List.prototype.insertRange = overload([Number, [Array, List]],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Number} index - \u7D22\u5F15\r\n             * @param {T[] | List<T>} list - \u5217\u8868\r\n             */\r\n            function (index, list) {\r\n                this.#rangeCheck(index);\r\n\r\n                for (let item of list) {\r\n                    this.insert(index++, item);\r\n                }\r\n            }).add([Number, \"...\"],\r\n                /**\r\n                 * @this {List<T>}\r\n                 * @param {Number} index - \u7D22\u5F15\r\n                 * @param {T[]} items - \u9879\u76EE\r\n                 */\r\n                function (index, ...items) {\r\n                    this.#rangeCheck(index);\r\n\r\n                    for (let item of items) {\r\n                        this.insert(index++, item);\r\n                    }\r\n                });\r\n\r\n        return this.insertRange(...params);\r\n    }\r\n\r\n    indexOf(...params) {\r\n        this.indexOf = overload([this.#innerType],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {T} item - \u9879\u76EE\r\n             * @returns {Number}\r\n             */\r\n            function (item) {\r\n                return this.#list.indexOf(item);\r\n            });\r\n\r\n        return this.indexOf(...params);\r\n    }\r\n\r\n    lastIndexOf(...params) {\r\n        this.lastIndexOf = overload([this.#innerType],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {T} item - \u9879\u76EE\r\n             * @returns {Number}\r\n             */\r\n            function (item) {\r\n                return this.#list.lastIndexOf(item);\r\n            });\r\n\r\n        return this.lastIndexOf(...params);\r\n    }\r\n\r\n    remove(...params) {\r\n        this.remove = overload([this.#innerType],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {T} item - \u9879\u76EE\r\n             * @returns {Boolean}\r\n             */\r\n            function (item) {\r\n                const index = this.#list.indexOf(item);\r\n\r\n                if (index !== -1) {\r\n                    this.#list.splice(index, 1);\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            });\r\n\r\n        return this.remove(...params);\r\n    }\r\n\r\n    removeAt(...params) {\r\n        List.prototype.removeAt = overload([Number],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Number} index - \u7D22\u5F15 \r\n             */\r\n            function (index) {\r\n                this.#rangeCheck(index);\r\n\r\n                this.#list.splice(index, 1);\r\n            });\r\n\r\n        return this.removeAt(...params);\r\n    }\r\n\r\n    removeAll(...params) {\r\n        List.prototype.removeAll = overload([Function],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Function} predicate - \u8C13\u8BCD\r\n             * @returns {Number}\r\n             */\r\n            function (predicate) {\r\n                let count = 0;\r\n\r\n                for (let i = this.#list.length - 1; i >= 0; i--) {\r\n                    if (predicate(this.#list[i])) {\r\n                        this.#list.splice(i, 1);\r\n                        count++;\r\n                    }\r\n                }\r\n\r\n                return count;\r\n            });\r\n\r\n        return this.removeAll(...params);\r\n    }\r\n\r\n    removeRange(...params) {\r\n        List.prototype.removeRange = overload([Number, Number],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Number} index - \u7D22\u5F15\r\n             * @param {Number} count - \u6570\u91CF\r\n             */\r\n            function (index, count) {\r\n                this.#rangeCheck(index);\r\n                this.#rangeCheck(index + count - 1);\r\n\r\n                this.#list.splice(index, count);\r\n            });\r\n\r\n        return this.removeRange(...params);\r\n    }\r\n\r\n    reverse(...params) {\r\n        List.prototype.reverse = overload([],\r\n            /**\r\n             * @this {List<T>}\r\n             */\r\n            function () {\r\n                this.#list.reverse();\r\n            })\r\n            .add([Number, Number],\r\n                /**\r\n                 * @this {List<T>}\r\n                 * @param {Number} index - \u7D22\u5F15\r\n                 * @param {Number} count - \u6570\u91CF \r\n                 */\r\n                function (index, count) {\r\n                    this.#rangeCheck(index);\r\n                    this.#rangeCheck(index + count - 1);\r\n\r\n                    const temp = this.#list.splice(index, count);\r\n                    temp.reverse();\r\n                    this.#list.splice(index, 0, ...temp);\r\n                });\r\n\r\n        return this.reverse(...params);\r\n    }\r\n\r\n    slice(...params) {\r\n        List.prototype.slice = overload().add([Number, Number],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Number} start - \u5F00\u59CB\r\n             * @param {Number} end - \u7ED3\u675F\r\n             * @returns {List<T>}\r\n             */\r\n            function (start, end) {\r\n                return new List(this.#innerType, this.#list.slice(start, end));\r\n            });\r\n\r\n        return this.slice(...params);\r\n    }\r\n\r\n    sort(...params) {\r\n        List.prototype.sort = overload()\r\n            .add([],\r\n                /**\r\n                 * @this {List<T>}\r\n                 */\r\n                function () {\r\n                    this.#list.sort();\r\n                })\r\n            .add([Function],\r\n                /**\r\n                 * @this {List<T>}\r\n                 * @param {Function} compareFn - \u6BD4\u8F83\u51FD\u6570 \r\n                 */\r\n                function (compareFn) {\r\n                    this.#list.sort(compareFn);\r\n                });\r\n\r\n        return this.sort(...params);\r\n    }\r\n\r\n    toArray(...params) {\r\n        List.prototype.toArray = overload([],\r\n            /**\r\n             * @this {List<T>}\r\n             * @returns {T[]}\r\n             */\r\n            function () {\r\n                return this.#list.slice();\r\n            });\r\n\r\n        return this.toArray(...params);\r\n    }\r\n\r\n    trueForAll(...params) {\r\n        List.prototype.trueForAll = overload([Function],\r\n            /**\r\n             * @this {List<T>}\r\n             * @param {Function} predicate - \u8C13\u8BCD\r\n             * @returns {Boolean}\r\n             */\r\n            function (predicate) {\r\n                return this.#list.every(predicate);\r\n            });\r\n\r\n        return this.trueForAll(...params);\r\n    }\r\n\r\n    toString(...params) {\r\n        List.prototype.toString = overload().any(\r\n            /**\r\n             * @this {List<T>}\r\n             * @param  {...any} params - \u53C2\u6570\r\n             * @returns {String}\r\n             */\r\n            function (...params) {\r\n                return this.#list.toString(...params);\r\n            });\r\n\r\n        return this.toString(...params);\r\n    }\r\n}"],
  "mappings": "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",
  "names": ["INNER_TYPE_FATHER", "INNER_TYPE_SON", "INNER_THROW_FN", "INNER_TYPE_FN", "matchType", "param", "type", "i", "INNER_TYPE_FN", "INNER_TYPE_SON", "INNER_TYPE_FATHER", "getTypeName", "paramType", "className", "v", "throwStackInfo", "err", "types", "args", "stackList", "errorMessage", "formattedStack", "errorMethodName", "stackLine", "index", "arr", "parts", "fullMethodName", "methodName", "matchingTypes", "hasError", "expectedType", "expectedTypeNames", "INNER_THROW_FN", "createOverload", "TYPES", "FNS", "OPTIONS", "anyFn", "runAny", "overload", "params", "paramsLength", "loop", "options", "typesLength", "j", "convert", "fn", "key", "isArray", "typeofStr", "src_default", "result", "_CodeOrName", "exports", "Name", "s", "_Code", "code", "item", "e", "_a", "c", "names", "_", "strs", "args", "i", "addCodeArg", "plus", "str", "expr", "safeStringify", "optimize", "arg", "interpolate", "res", "mergeExprItems", "a", "b", "strConcat", "c1", "c2", "x", "stringify", "getProperty", "key", "getEsmExportName", "regexpCode", "rx", "code_1", "We", "ValueError", "name", "UsedValueState", "Scope", "prefixes", "parent", "nameOrPrefix", "prefix", "ng", "r", "_b", "ValueScopeName", "nameStr", "value", "property", "itemIndex", "line", "ValueScope", "opts", "valueKey", "vs", "_name", "keyOrRef", "scopeName", "values", "usedValues", "getCode", "valueCode", "nameSet", "def", "scope_1", "ir", "code_2", "scope_2", "Node", "_names", "_constants", "Def", "varKind", "rhs", "es5", "_n", "constants", "optimizeExpr", "Assign", "lhs", "sideEffects", "addExprNames", "AssignOp", "op", "Label", "label", "Break", "Throw", "error", "AnyCode", "ParentNode", "nodes", "n", "subtractNames", "addNames", "BlockNode", "Root", "Else", "If", "_If", "condition", "cond", "ns", "not", "For", "ForLoop", "iteration", "ForRange", "from", "to", "ForIter", "loop", "iterable", "Func", "async", "Return", "Try", "Catch", "Finally", "CodeGen", "extScope", "prefixOrName", "constant", "_constant", "keyValues", "thenBody", "elseBody", "node", "forBody", "arr", "obj", "tryBody", "catchCode", "finallyCode", "body", "nodeCount", "len", "toClose", "funcBody", "N1", "N2", "replaceName", "canOptimize", "items", "par", "andCode", "mappend", "and", "orCode", "or", "y", "R", "S", "codegen_1", "P", "toHash", "hash", "alwaysValidSchema", "it", "schema", "checkUnknownRules", "schemaHasRules", "self", "rules", "checkStrictMode", "schemaHasRulesButRef", "RULES", "schemaRefOrVal", "topSchemaRef", "schemaPath", "keyword", "$data", "unescapeFragment", "unescapeJsonPointer", "escapeFragment", "escapeJsonPointer", "eachItem", "xs", "f", "makeMergeEvaluated", "mergeNames", "mergeToName", "mergeValues", "resultToName", "gen", "toName", "setEvaluated", "evaluatedPropsToName", "ps", "props", "p", "snippets", "useFunc", "Type", "getErrorPath", "dataProp", "dataPropType", "jsPropertySyntax", "isNumber", "msg", "mode", "util_1", "names_1", "schemaType", "reportError", "cxt", "errorPaths", "overrideAllErrors", "compositeRule", "allErrors", "errObj", "errorObjectCode", "addError", "returnErrors", "reportExtraError", "resetErrorsCount", "errsCount", "extendErrors", "schemaValue", "data", "err", "errs", "validateName", "schemaEnv", "E", "createErrors", "errorObject", "errorInstancePath", "errorSchemaPath", "extraErrorProps", "errorPath", "instancePath", "instPath", "errSchemaPath", "parentSchema", "schPath", "params", "message", "propertyName", "an", "Te", "errors_1", "et", "boolError", "topBoolOrEmptySchema", "falseSchemaError", "boolOrEmptySchema", "valid", "Pr", "Ce", "_jsonTypes", "jsonTypes", "isJSONType", "getRules", "groups", "schemaHasRulesForType", "type", "group", "shouldUseGroup", "rule", "shouldUseRule", "kwd", "rules_1", "applicability_1", "Sr", "DataType", "getSchemaTypes", "types", "getJSONTypes", "ts", "coerceAndCheckDataType", "coerceTo", "coerceToTypes", "checkTypes", "wrongType", "checkDataTypes", "coerceData", "reportTypeError", "COERCIBLE", "coerceTypes", "t", "dataType", "coerced", "coerceSpecificType", "assignParentData", "parentData", "parentDataProperty", "checkDataType", "strictNums", "correct", "EQ", "numCond", "_cond", "dataTypes", "notObj", "typeError", "getTypeErrorContext", "schemaCode", "hn", "qt", "assignDefaults", "ty", "properties", "assignDefault", "sch", "prop", "defaultValue", "childData", "Q", "I", "util_2", "checkReportMissingProp", "noPropertyInData", "checkMissingProp", "missing", "reportMissingProp", "hasPropFunc", "isOwnProperty", "propertyInData", "ownProperties", "allSchemaProperties", "schemaMap", "schemaProperties", "callValidateCode", "func", "context", "passSchema", "dataAndSchema", "valCxt", "newRegExp", "usePattern", "pattern", "u", "regExp", "validateArray", "validArr", "validateItems", "notValid", "validateUnion", "schValid", "_sch", "schCxt", "macroKeywordCode", "macroSchema", "schemaRef", "useKeyword", "funcKeywordCode", "checkAsyncKeyword", "validate", "validateRef", "validateKeyword", "assignValid", "modifyData", "reportErrs", "ruleErrs", "validateAsync", "validateSync", "addErrs", "validateErrs", "_await", "passCxt", "errors", "q", "result", "validSchemaType", "allowUndefined", "st", "validateKeywordUsage", "deps", "getSubschema", "schemaProp", "extendSubschemaData", "subschema", "dpType", "dataPathArr", "nextData", "dataContextProps", "_nextData", "extendSubschemaMode", "jtdDiscriminator", "jtdMetadata", "require_fast_deep_equal", "__commonJSMin", "module", "equal", "length", "keys", "require_json_schema_traverse", "traverse", "cb", "pre", "post", "_traverse", "jsonPtr", "rootSchema", "parentJsonPtr", "parentKeyword", "keyIndex", "escapeJsonPtr", "rt", "J", "Ir", "En", "SIMPLE_INLINED", "inlineRef", "limit", "hasRef", "countKeys", "REF_KEYWORDS", "count", "getFullPath", "resolver", "id", "normalize", "normalizeId", "_getFullPath", "TRAILING_SLASH_HASH", "resolveUrl", "baseId", "ANCHOR", "getSchemaRefs", "schemaId", "uriResolver", "schId", "baseIds", "pathPrefix", "localRefs", "schemaRefs", "fullPath", "innerBaseId", "addRef", "addAnchor", "ref", "_resolve", "ambiguos", "schOrRef", "checkAmbiguosRef", "anchor", "sch1", "sch2", "boolSchema_1", "dataType_1", "tt", "dataType_2", "defaults_1", "keyword_1", "gn", "subschema_1", "vn", "resolve_1", "validateFunctionCode", "isSchemaObj", "checkKeywords", "schemaCxtHasRules", "topSchemaObjCode", "validateFunction", "funcSourceUrl", "destructureValCxtES5", "destructureValCxt", "commentKeyword", "checkNoDefault", "resetEvaluated", "typeAndKeywords", "returnResults", "subschemaCode", "subSchemaObjCode", "updateContext", "checkAsyncSchema", "checkRefsAndKeywords", "schemaKeywords", "checkedTypes", "rootName", "ValidationError", "assignEvaluated", "evaluated", "typeErrors", "keywordCode", "checkStrictTypes", "groupKeywords", "iterateKeywords", "useDefaults", "checkContextTypes", "checkMultipleTypes", "checkKeywordTypes", "includesType", "strictTypesError", "narrowSchemaTypes", "hasApplicableType", "schTs", "kwdT", "withTypes", "KeywordCxt", "getData", "successAction", "failAction", "append", "errorParams", "assign", "codeBlock", "$dataValid", "wrong$DataType", "invalid$DataSchema", "validateSchemaRef", "appl", "nextContext", "schemaCxt", "ruleType", "JSON_POINTER", "RELATIVE_JSON_POINTER", "dataLevel", "dataNames", "jsonPointer", "matches", "up", "errorMsg", "segments", "segment", "pointerType", "MissingRefError", "validation_error_1", "It", "validate_1", "at", "SchemaEnv", "env", "compileSchema", "getCompilingSchema", "rootId", "lines", "_ValidationError", "sourceCode", "validateCode", "resolveRef", "root", "schOrFunc", "resolve", "inlineOrCompile", "schEnv", "sameSchemaEnv", "s1", "s2", "resolveSchema", "refPath", "getJsonPointer", "PREVENT_SCOPE_CHANGE", "parsedRef", "part", "partSchema", "$ref", "require_data", "require_scopedChars", "HEX", "require_utils", "Hn", "normalizeIPv4", "host", "findToken", "address", "stripLeadingZeros", "stringArrayToHexStripped", "input", "keepZero", "acc", "strip", "getIPV6", "tokenCount", "output", "buffer", "isZone", "endipv6Encountered", "endIpv6", "consume", "hex", "cursor", "normalizeIPv6", "ipv6", "newHost", "escapedHost", "token", "out", "skip", "l", "ind", "RDS1", "RDS2", "RDS3", "RDS5", "removeDotSegments", "im", "normalizeComponentEncoding", "components", "esc", "recomposeAuthority", "options", "uriTokens", "ipV4res", "ipV6res", "require_schemes", "UUID_REG", "URN_REG", "isSecure", "wsComponents", "httpParse", "httpSerialize", "secure", "wsParse", "wsSerialize", "path", "query", "urnParse", "urnComponents", "scheme", "urnScheme", "schemeHandler", "SCHEMES", "urnSerialize", "nid", "uriComponents", "nss", "urnuuidParse", "uuidComponents", "urnuuidSerialize", "http", "https", "ws", "wss", "urn", "urnuuid", "require_fast_uri", "Zn", "aa", "uri", "serialize", "parse", "baseURI", "relativeURI", "schemelessOptions", "resolved", "resolveComponents", "base", "relative", "skipNormalization", "target", "uriA", "uriB", "cmpts", "authority", "hexLookUp", "v", "k", "nonSimpleDomain", "URI_PARSE", "parsed", "gotEncoding", "isIP", "ipv4result", "ipv6result", "fastUri", "ia", "ref_error_1", "ot", "compile_1", "Ct", "codegen_2", "$dataRefSchema", "xn", "uri_1", "ua", "defaultRegExp", "flags", "META_IGNORE_OPTIONS", "EXT_SCOPE_NAMES", "removedOptions", "deprecatedOptions", "MAX_EXPRESSION", "requiredOptions", "o", "d", "m", "h", "g", "N", "C", "w", "se", "ce", "er", "tr", "_optz", "_c", "_d", "_f", "_e", "_h", "_g", "_k", "_j", "_m", "_l", "_p", "_o", "_q", "_r", "_s", "_t", "_u", "_v", "_w", "_x", "_y", "_z", "_0", "Ajv", "getLogger", "formatOpt", "checkOptions", "getMetaSchemaOptions", "addInitialFormats", "addInitialKeywords", "addInitialSchemas", "meta", "_dataRefSchema", "schemaKeyRef", "_meta", "loadSchema", "runCompileAsync", "_schema", "loadMetaSchema", "_compileAsync", "checkLoaded", "loadMissingSchema", "missingRef", "_loadSchema", "_validateSchema", "throwOrLogError", "$schema", "keyRef", "getSchEnv", "cacheKey", "definitions", "kwdOrDef", "checkKeyword", "addRule", "keywordMetaschema", "definition", "format", "separator", "dataVar", "text", "metaSchema", "keywordsJsonPointers", "keywords", "seg", "schemaOrData", "schemas", "regex", "validateSchema", "addSchema", "currentOpts", "V", "checkOpts", "log", "opt", "optsSchemas", "defs", "metaOpts", "noLogs", "logger", "KEYWORD_NAME", "ruleGroup", "addBeforeRule", "before", "_rule", "$dataRef", "ga", "Xr", "callRootRef", "schOrEnv", "callValidate", "inlineRefSchema", "callRef", "getValidate", "schName", "$async", "callAsyncRef", "callSyncRef", "addEvaluatedFrom", "addErrorsFrom", "source", "schEvaluated", "id_1", "ref_1", "ba", "core", "ops", "KWDs", "prec", "invalid", "ucs2length", "pos", "qa", "rs", "ucs2length_1", "ka", "comp", "missingProperty", "useLoop", "allErrorsMode", "exitOnErrorMode", "definedProperties", "requiredKey", "loopAllRequired", "loopUntilMissing", "equal_1", "Lt", "j", "itemTypes", "validateUniqueItems", "loopN", "loopN2", "indices", "eql", "outer", "getEql", "loopEnum", "vSchema", "equalCode", "limitNumber_1", "Pa", "multipleOf_1", "Sa", "limitLength_1", "pattern_1", "Oa", "limitProperties_1", "ja", "required_1", "Ra", "limitItems_1", "Ia", "uniqueItems_1", "Ca", "const_1", "Ma", "enum_1", "Aa", "validation", "validateAdditionalItems", "validateTuple", "extraItems", "schArr", "checkStrictTuple", "fullTuple", "items_1", "ys", "additionalItems_1", "ms", "prefixItems", "min", "max", "minContains", "maxContains", "validateItemsWithCount", "checkLimits", "_valid", "block", "depsCount", "property_ies", "propDeps", "schDeps", "splitDependencies", "validatePropertyDeps", "validateSchemaDeps", "propertyDeps", "schemaDeps", "hasProperty", "depProp", "patProps", "checkAdditionalProperties", "additionalPropertyCode", "isAdditional", "definedProp", "propsSchema", "deleteAdditional", "applyAdditionalSchema", "additionalProperties_1", "Es", "allProps", "hasDefault", "applyPropertySchema", "patterns", "alwaysValidPatterns", "checkProperties", "validatePatternProperties", "pat", "checkMatchingProperties", "validateProperties", "alwaysValid", "passing", "validateOneOf", "hasThen", "hasSchema", "hasElse", "validateIf", "ifClause", "validateClause", "prefixItems_1", "Ka", "items2020_1", "xa", "contains_1", "La", "dependencies_1", "Ja", "propertyNames_1", "Ya", "properties_1", "Ba", "patternProperties_1", "ro", "not_1", "so", "anyOf_1", "no", "oneOf_1", "ao", "allOf_1", "oo", "if_1", "uo", "thenElse_1", "lo", "getApplicator", "draft2020", "applicator", "validate$DataFormat", "validateFormat", "fmts", "fDef", "fType", "unknownFmt", "invalidFmt", "callFormat", "validData", "formatDef", "unknownFormat", "fmtType", "fmtRef", "getFormat", "validCondition", "unknownMsg", "fmtDef", "fmt", "format_1", "ho", "As", "core_1", "Ea", "validation_1", "Da", "applicator_1", "fo", "po", "metadata_1", "mo", "draft7Vocabularies", "DiscrError", "wo", "Vs", "types_1", "$o", "discrError", "tagName", "tag", "oneOf", "validateMapping", "mapping", "getMapping", "tagValue", "applyTagSchema", "oneOfMapping", "topRequired", "hasRequired", "tagRequired", "propSch", "addMappings", "required", "addMapping", "require_json_schema_draft_07", "Po", "A", "zs", "draft7_1", "discriminator_1", "draft7MetaSchema", "bo", "META_SUPPORT_DATA", "META_SCHEMA_ID", "require_zh", "import_ajv", "Do", "INNER_THROW_FN", "INNER_TYPE_FN", "localize", "qo", "ajv", "Oo", "JSONSchema", "#validate", "List", "_List", "#list", "#innerType", "#proxy", "#_constructor", "params", "src_default", "Us", "innerType", "list", "item", "count", "defaultValue", "i", "#initProxy", "CACHE_T_PROXY", "proxy", "target", "prop", "receiver", "result", "value", "#rangeCheck", "index", "items", "ignore", "newList", "array", "arrayIndex", "predicate", "callback", "find", "temp", "start", "end", "compareFn"]
}
